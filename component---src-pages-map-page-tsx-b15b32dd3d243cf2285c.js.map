{"version":3,"sources":["webpack:///./node_modules/@turf/destination/main.es.js","webpack:///./node_modules/@turf/invariant/main.es.js","webpack:///./node_modules/@turf/circle/main.es.js","webpack:///./src/pages/MapPage.tsx","webpack:///./src/image/place.svg","webpack:///./src/utils/tileTree.ts","webpack:///./src/components/MeshFeature.tsx","webpack:///./src/components/GrayScaleFilter.tsx","webpack:///./src/components/MapApp.tsx"],"names":["destination_main_es","origin","distance","bearing","options","Object","main_es","Error","units","properties","coordinates1","coord","type","geometry","coordinates","Array","isArray","length","undefined","getCoord","longitude1","latitude1","bearing_rad","radians","latitude2","Math","asin","sin","cos","longitude2","atan2","lng","lat","circle_main_es","center","radius","steps","i","push","buffer","circle","withStyles","theme","createStyles","root","autoSizerWrapper","height","props","core_browser_esm","className","classes","AppBar_default","a","position","Toolbar_default","Typography_default","variant","es","_ref","width","MapApp","feature","module","exports","TileSet","this","tileUrl","url","tileTree","treeIncludesTile","tile","x","y","z","hasOwnProperty","toString","tile2tree","_x$toString","_this$tileTree$z$toSt","_this$tileTree$z$toSt2","fetchTiles","tiles","_this","Promise","resolve","tasks","map","fetchTile","all","then","data","_this2","fetchUrl","replace","fetch","res","ok","blob","tileWithURL","assign","URL","createObjectURL","catch","isRequireFetch","_this3","every","setTileUrlFromTree","_this4","filter","updateTiles","_callee","newTiles","tilesInTree","tilesShouldFetch","fetchedTiles","_this5","regenerator_default","wrap","_context","prev","next","sent","abrupt","concat","stop","colorScale","scaleSequential","interpolateSpectral","domain","sizeScale","scalePow","range","exponent","MeshRect","projection","val","size","abs","max","scale","fill","fillOpacity","style","mixBlendMode","filterMatrix","GrayScaleFilter","id","values","join","d3tile","require","Map","state","fetchStatus","_tileSet","_getTileCoordinates","_this$props","PI","translate","v","index","array","mag","_fetchTiles","componentDidMount","render","_this$props2","buffers","geojson","mapState","popVisibility","bufferVisibility","zoomLevel","geoMercator","fitExtent","path","geoPath","tileCoords","renderTiles","setState","components_GrayScaleFilter","opacity","key","xlinkHref","points","features","MeshFeature","bb","bbox","lb","d","stroke","strokeWidth","dy","textAnchor","fontWeight","Place","transform","React","&:hover"],"mappings":"+NAsDe,IAAAA,EAzBf,SAAAC,EAAAC,EAAAC,EAAAC,GAGA,GADAA,KAAA,IACSC,OAAAC,EAAA,EAAAD,CAAQD,GAAA,UAAAG,MAAA,sBACjB,IAAAC,EAAAJ,EAAAI,MACAC,EAAAL,EAAAK,WAGAC,ECvBA,SAAAC,GACA,IAAAA,EAAA,UAAAJ,MAAA,qBACA,eAAAI,EAAAC,MAAA,OAAAD,EAAAE,UAAA,UAAAF,EAAAE,SAAAD,KAAA,OAAAD,EAAAE,SAAAC,YACA,aAAAH,EAAAC,KAAA,OAAAD,EAAAG,YACA,GAAAC,MAAAC,QAAAL,MAAAM,QAAA,QAAAC,IAAAP,EAAA,GAAAM,aAAAC,IAAAP,EAAA,GAAAM,OAAA,OAAAN,EAEA,UAAAJ,MAAA,sDDiBuBY,CAAQlB,GAC/BmB,EAAqBf,OAAAC,EAAA,EAAAD,CAAgBK,EAAA,IACrCW,EAAoBhB,OAAAC,EAAA,EAAAD,CAAgBK,EAAA,IACpCY,EAAsBjB,OAAAC,EAAA,EAAAD,CAAgBF,GACtCoB,EAAkBlB,OAAAC,EAAA,EAAAD,CAAeH,EAAAM,GAGjCgB,EAAAC,KAAAC,KAAAD,KAAAE,IAAAN,GAAAI,KAAAG,IAAAL,GACAE,KAAAG,IAAAP,GAAAI,KAAAE,IAAAJ,GAAAE,KAAAG,IAAAN,IACAO,EAAAT,EAAAK,KAAAK,MAAAL,KAAAE,IAAAL,GAAAG,KAAAE,IAAAJ,GAAAE,KAAAG,IAAAP,GACAI,KAAAG,IAAAL,GAAAE,KAAAE,IAAAN,GAAAI,KAAAE,IAAAH,IACAO,EAAc1B,OAAAC,EAAA,EAAAD,CAAgBwB,GAC9BG,EAAc3B,OAAAC,EAAA,EAAAD,CAAgBmB,GAE9B,OAAWnB,OAAAC,EAAA,EAAAD,CAAK,CAAA0B,EAAAC,GAAAvB,IEHD,IAAAwB,EAzBf,SAAAC,EAAAC,EAAA/B,GAGA,IAAAgC,GADAhC,KAAA,IACAgC,OAAA,GACA3B,EAAAL,EAAAK,WAGA,IAAAyB,EAAA,UAAA3B,MAAA,sBACA,IAAA4B,EAAA,UAAA5B,MAAA,sBACA,oBAAAH,EAAA,UAAAG,MAAA,6BACA,oBAAA6B,EAAA,UAAA7B,MAAA,0BAGA6B,KAAA,GACA3B,KAAAyB,EAAAzB,YAAA,GAGA,IADA,IAAAK,EAAA,GACAuB,EAAA,EAAmBA,EAAAD,EAAWC,IAC9BvB,EAAAwB,KAAyBtC,EAAWkC,EAAAC,GAAA,IAAAE,EAAAD,EAAAhC,GAAAS,SAAAC,aAIpC,OAFAA,EAAAwB,KAAAxB,EAAA,IAEWT,OAAAC,EAAA,EAAAD,CAAO,CAAAS,GAAAL,aCjCZ8B,EAASC,EADA,CAAC,OAAQ,OACM,IAAM,CAClChC,MAAO,WA0BMiC,cAvBA,SAACC,GAAD,OACbC,IAAa,CACXC,KAAM,GACNC,iBAAkB,CAChBC,OAAQ,yBAmBCL,CAbiC,SAACM,GAAD,OAC9C1C,OAAA2C,EAAA,EAAA3C,CAAA,OAAK4C,UAAWF,EAAMG,QAAQN,MAC5BvC,OAAA2C,EAAA,EAAA3C,CAAC8C,EAAAC,EAAD,CAAQC,SAAS,UACfhD,OAAA2C,EAAA,EAAA3C,CAACiD,EAAAF,EAAD,KACE/C,OAAA2C,EAAA,EAAA3C,CAACkD,EAAAH,EAAD,CAAYI,QAAQ,MAApB,cAGJnD,OAAA2C,EAAA,EAAA3C,CAAA,OAAK4C,UAAWF,EAAMG,QAAQL,kBAC5BxC,OAAA2C,EAAA,EAAA3C,CAACoD,EAAA,EAAD,KAAY,SAAAC,GAAA,IAAGC,EAAHD,EAAGC,MAAOb,EAAVY,EAAUZ,OAAV,OAAuBzC,OAAA2C,EAAA,EAAA3C,CAACuD,EAAA,EAAD,CAAQD,MAAOA,EAAOb,OAAQA,EAAQe,QAAStB,6BClCxFuB,EAAAC,QAAA,uwBC+HeC,aA5Fb,SAAAA,EAAY5D,QAA8B,IAA9BA,MAA0B,IACpC6D,KAAKC,QAAU9D,EAAQ+D,KAAO,qDAC9BF,KAAKG,SAAW,8BAGVC,iBAAR,SAAyBC,GAAqB,IACpCC,EAAYD,EAAZC,EAAGC,EAASF,EAATE,EAAGC,EAAMH,EAANG,EACd,OACER,KAAKG,SAASM,eAAeD,EAAEE,aAC/BV,KAAKG,SAASK,EAAEE,YAAYD,eAAeH,EAAEI,aAC7CV,KAAKG,SAASK,EAAEE,YAAYJ,EAAEI,YAAYD,eAAeF,EAAEG,eAIvDC,UAAR,SAAkBN,GAAmB,IAEcO,EAAAC,EADzCP,EAAiBD,EAAjBC,EAAGC,EAAcF,EAAdE,EAAGC,EAAWH,EAAXG,EAAGN,EAAQG,EAARH,IACjB,GAAKF,KAAKG,SAASM,eAAeD,EAAEE,YAM7B,GAAKV,KAAKG,SAASK,EAAEE,YAAYD,eAAeH,EAAEI,YAKvDV,KAAKG,SAASK,EAAEE,YAAYJ,EAAEI,YAAYH,EAAEG,YAAcR,MALU,KAAAY,EACpEd,KAAKG,SAASK,EAAEE,YAAYJ,EAAEI,cAA9BI,EAAA,IACGP,EAAEG,YAAaR,EADlBY,QANAd,KAAKG,SAASK,EAAEE,cAAhBG,EAAA,IACGP,EAAEI,cADLE,EAAA,IAEKL,EAAEG,YAAaR,EAFpBU,GAAAC,MAcIE,WAAR,SAAmBC,GAAuC,IAAAC,EAAAjB,KACxD,OAAO,IAAIkB,QAAQ,SAAAC,GACjB,IAAMC,EAAQJ,EAAMK,IAAI,SAAAhB,GAAI,OAAIY,EAAKK,UAAUjB,EAAMY,EAAKhB,WAC1DiB,QAAQK,IAAIH,GAAOI,KAAK,SAACC,GACvBN,EAAQM,UAINH,UAAR,SAAkBjB,EAAYH,GAAmC,IAAAwB,EAAA1B,KACvDM,EAAYD,EAAZC,EAAGC,EAASF,EAATE,EAAGC,EAAMH,EAANG,EACRmB,EAAWzB,EAAI0B,QAAQ,cAAkBpB,EAA9B,IAAmCF,EAAnC,IAAwCC,GAEzD,OAAOsB,IAAMF,GACVH,KAAK,SAAAM,GACJ,IAAKA,EAAIC,GAAI,MAAM,IAAIzF,MACvB,OAAOwF,EAAIE,SAEZR,KAAK,SAAAQ,GACJ,IAAMC,EAAwB7F,OAAA8F,OAAA,GACzB7B,EADyB,CAE5BH,IAAKiC,IAAIC,gBAAgBJ,KAG3B,OADAN,EAAKf,UAAUsB,GACRA,IAERI,MAAM,WACL,IAAMJ,EAAwB7F,OAAA8F,OAAA,GACzB7B,EADyB,CAE5BH,SAAKjD,IAGP,OADAyE,EAAKf,UAAUsB,GACRA,OAMNK,eAAP,SAAsBtB,GAAwB,IAAAuB,EAAAvC,KAC5C,OAAQgB,EAAMwB,MAAM,SAAAnC,GAAI,OAAIkC,EAAKnC,iBAAiBC,QAG7CoC,mBAAP,SAA0BzB,GAA8B,IAAA0B,EAAA1C,KACtD,OAAOgB,EACJ2B,OAAO,SAAAtC,GAAI,OAAIqC,EAAKtC,iBAAiBC,KACrCgB,IAAI,SAAAhB,GAAI,OAAAjE,OAAA8F,OAAA,GACJ7B,EADI,CAEPH,IAAKwC,EAAKvC,SAASE,EAAKG,GAAGH,EAAKC,GAAGD,EAAKE,UAIjCqC,0CAAb,SAAAC,EAAyBC,GAAzB,IAAAC,EAAAC,EAAAC,EAAAC,EAAAlD,KAAA,OAAAmD,EAAAhE,EAAAiE,KAAA,SAAAC,GAAA,cAAAA,EAAAC,KAAAD,EAAAE,MAAA,cACQR,EAAc/C,KAAKyC,mBAAmBK,EAASH,OAAO,SAAAtC,GAAI,OAAI6C,EAAK9C,iBAAiBC,MAEpF2C,EAAmBF,EAASH,OAAO,SAAAtC,GAAI,OAAK6C,EAAK9C,iBAAiBC,KAH1EgD,EAAAE,KAAA,EAK4CvD,KAAKe,WAAWiC,GAL5D,cAKQC,EALRI,EAAAG,KAAAH,EAAAI,OAAA,YAAAC,OAOaX,EAAgBE,IAP7B,wBAAAI,EAAAM,SAAAd,EAAA7C,sFCvGI4D,EAAaC,YAAgBC,KAAqBC,OAAO,CAAC,IAAM,IAEhEC,EAAYC,cACfF,OAAO,CAAC,EAAG,MACXG,MAAM,CAAC,EAAG,IACVC,SAAS,IAqBGC,EAnBkC,SAACtF,GAAiB,IACzDc,EAAwBd,EAAxBc,QAASyE,EAAevF,EAAfuF,WACTC,EAAQ1E,EAAQpD,WAAhB8H,IACFrG,EAASoG,EAAWzE,EAAQhD,SAASC,aACrC0H,EAAO/G,KAAKgH,IAAIR,EAAUM,GAAO9G,KAAKiH,IAAI,EAAGJ,EAAWK,QAAU,QAExE,OACEtI,OAAA2C,EAAA,EAAA3C,CAAA,QACEuI,KAAMf,EAAWU,GACjBM,YAAa,GACbtE,EAAGrC,EAAO,GAAKsG,EAAO,EACtBhE,EAAGtC,EAAO,GAAKsG,EAAO,EACtB7E,MAAO6E,EACP1F,OAAQ0F,EACRM,MAAO,CAAEC,aAAc,eCzBvBC,EAAe,CAAC,2BAA4B,2BAA4B,2BAA4B,aAY3FC,EANyC,SAAClG,GAAD,OACtD1C,OAAA2C,EAAA,EAAA3C,CAAA,UAAQ6I,GAAInG,EAAMmG,IAChB7I,OAAA2C,EAAA,EAAA3C,CAAA,iBAAeO,KAAK,SAASuI,OAAQH,EAAaI,KAAK,2BCbrDC,EAASC,EAAQ,KAAWhF,KAiD5BiF,sJACKC,MAAe,CACtBC,YAAa,SAEfC,SAAW,IAAI1F,IAIP2F,oBAAsB,SAACrB,GAAsC,IAAAsB,EACzC1E,EAAKnC,MAAvBY,EAD2DiG,EAC3DjG,MAAOb,EADoD8G,EACpD9G,OAef,OAZsBuG,IACnBb,KAAK,CAHY,IAGX7E,EAHW,IAGEb,IACnB6F,MAA2B,EAArBL,EAAWK,QAAclH,KAAKoI,GAJnB,KAKjBC,UAAUxB,EAAW,CAAC,EAAG,IAAIhD,IAAI,SAAAyE,GAAC,OALjB,IAKqBA,IAHnBV,GAInB/D,IAAI,SAAChB,EAA2C0F,EAAeC,GAA3D,OAAA5J,OAAA8F,OAAA,GACA7B,EADA,CAEH4F,IARgB,IAShBhB,GAAO5E,EAAKG,EAAV,IAAeH,EAAKC,EAApB,IAAyBD,EAAKE,EAChCmE,MAAOsB,EAAMtB,MACbmB,UAAWG,EAAMH,iBAMfK,YAAc,SAAClF,GACrB,OAAOC,EAAKwE,SAAS7C,YAAY5B,0CAGnCmF,kBAAA,eAEOC,OAAP,WAAgB,IAAA1E,EAAA1B,KAAAqG,EACkCrG,KAAKlB,MAA7CG,EADMoH,EACNpH,QAASqH,EADHD,EACGC,QAASC,EADZF,EACYE,QAASC,EADrBH,EACqBG,SAC3BC,EAA+CD,EAA/CC,cAAeC,EAAgCF,EAAhCE,iBAAkBC,EAAcH,EAAdG,UACnCjH,EAAQM,KAAKlB,MAAMY,OAAS,IAC5Bb,EAASmB,KAAKlB,MAAMD,QAAU,IAC9BwF,EAAaiC,EAAUM,cAAcC,UAAU,CAAC,CAAC,GAAI,IAAK,CAACnH,EAAQ,GAAIb,EAAS,KAAMyH,EAAQK,IAAcC,cAE5GE,EAAgBC,YAAQ1C,GACxB2C,EAAahH,KAAK0F,oBAAoBrB,GAExC4C,EAA6BjH,KAAKyF,SAAShD,mBAAmBuE,GAQlE,OANIhH,KAAKyF,SAASnD,eAAe0E,IAC/BhH,KAAKkG,YAAYc,GAAYxF,KAAK,SAAAsB,GAChCpB,EAAKwF,SAAS,CAAE1B,YAAa,cAK/BpJ,OAAA2C,EAAA,EAAA3C,CAAA,OAAK4C,UAAWC,EAAQN,KAAMe,MAAOA,EAAOb,OAAQA,GAClDzC,OAAA2C,EAAA,EAAA3C,CAAA,SACEA,OAAA2C,EAAA,EAAA3C,CAAC+K,EAAD,CAAiBlC,GAAG,cACpB7I,OAAA2C,EAAA,EAAA3C,CAAA,KAAGuG,OAAO,kBAAkB3D,UAAWC,EAAQ+B,MAAO6D,MAAO,CAAEuC,QAAoC,YAA3BpH,KAAKuF,MAAMC,YAA4B,EAAI,IAChHyB,EAAY5F,IAAI,SAAChB,EAAM0F,GAAP,OACf3J,OAAA2C,EAAA,EAAA3C,CAAA,SACEiL,IAAKtB,EACLuB,UAAWjH,EAAKH,IAChBI,GAAKD,EAAKC,EAAID,EAAKwF,UAAU,IAAMxF,EAAKqE,MAASrE,EAAK4F,IACtD1F,GAAKF,EAAKE,EAAIF,EAAKwF,UAAU,IAAMxF,EAAKqE,MAASrE,EAAK4F,IACtDvG,MAAOW,EAAKqE,MAAQrE,EAAK4F,IACzBpH,OAAQwB,EAAKqE,MAAQrE,EAAK4F,UAKjCQ,EACCrK,OAAA2C,EAAA,EAAA3C,CAAA,KAAG4C,UAAWC,EAAQsI,OAAQ1C,MAAO,CAAEuC,QAAoC,YAA3BpH,KAAKuF,MAAMC,YAA4B,EAAI,IACxFe,EACGA,EAAQiB,SAASnG,IAAI,SAACzB,EAASmG,GAAV,MACO,UAA1BnG,EAAQhD,SAASD,KAAmBP,OAAA2C,EAAA,EAAA3C,CAACqL,EAAD,CAAaJ,IAAKtB,EAAOnG,QAASA,EAASyE,WAAYA,IAAiB,OAE9G,MAEJ,KACHqC,EACCtK,OAAA2C,EAAA,EAAA3C,CAAA,SACGkK,EACGA,EAAQjF,IAAI,SAACzB,EAASmG,GACpB,IAAM2B,EAAKC,YAAK/H,GACVgI,EAAKvD,EAAW,CAACqD,EAAG,IAAMA,EAAG,GAAKA,EAAG,IAAM,EAAGA,EAAG,KACvD,OACEtL,OAAA2C,EAAA,EAAA3C,CAAA,KAAGiL,IAAKtB,EAAO/G,UAAWC,EAAQX,QAChClC,OAAA2C,EAAA,EAAA3C,CAAA,QAAMyL,EAAGf,EAAKlH,SAAY3C,EAAW0H,KAAK,OAAOmD,OAAO,mBAAmBC,YAAa,IACxF3L,OAAA2C,EAAA,EAAA3C,CAAA,QAAMkE,EAAGsH,EAAG,GAAIrH,EAAGqH,EAAG,GAAII,GAAG,MAAMC,WAAW,SAAStD,KAAK,mBAAmBE,MAAO,CAAEqD,WAAY,SACjGtI,EAAQpD,WAAW0B,WAK5B,MAEJ,KACJ9B,OAAA2C,EAAA,EAAA3C,CAAA,SACEA,OAAA2C,EAAA,EAAA3C,CAAA,SAAOkL,UAAWa,IAAO7H,EAAGZ,EAAQ,EAAGa,EAAG1B,EAAS,EAAGa,MAAO,GAAIb,OAAQ,GAAIuJ,UAAU,8BAhG/EC,aAuGH7J,QA5IA,SAACC,GAAD,OACbC,IAAa,CACXC,KAAM,GACNqC,MAAO,GAGP1C,OAAQ,CACN8I,QAAS,GACTkB,UAAW,CACTlB,QAAS,IAGbG,OAAQ,MAgIG/I,CAAmB8G","file":"component---src-pages-map-page-tsx-b15b32dd3d243cf2285c.js","sourcesContent":["import { getCoord } from '@turf/invariant';\nimport { degreesToRadians, isObject, lengthToRadians, point, radiansToDegrees } from '@turf/helpers';\n\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nfunction destination(origin, distance, bearing, options) {\n    // Optional parameters\n    options = options || {};\n    if (!isObject(options)) throw new Error('options is invalid');\n    var units = options.units;\n    var properties = options.properties;\n\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearing_rad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, units);\n\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));\n    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) * Math.sin(radians) * Math.cos(latitude1),\n        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n\n    return point([lng, lat], properties);\n}\n\nexport default destination;\n","import { isNumber } from '@turf/helpers';\n\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nfunction getCoord(coord) {\n    if (!coord) throw new Error('coord is required');\n    if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;\n    if (coord.type === 'Point') return coord.coordinates;\n    if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;\n\n    throw new Error('coord must be GeoJSON Point or an Array of numbers');\n}\n\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nfunction getCoords(coords) {\n    if (!coords) throw new Error('coords is required');\n\n    // Feature\n    if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;\n\n    // Geometry\n    if (coords.coordinates) return coords.coordinates;\n\n    // Array of numbers\n    if (Array.isArray(coords)) return coords;\n\n    throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');\n}\n\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nfunction containsNumber(coordinates) {\n    if (coordinates.length > 1 && isNumber(coordinates[0]) && isNumber(coordinates[1])) {\n        return true;\n    }\n\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error('coordinates must only contain numbers');\n}\n\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction geojsonType(value, type, name) {\n    if (!type || !name) throw new Error('type and name required');\n\n    if (!value || value.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nfunction featureOf(feature, type, name) {\n    if (!feature) throw new Error('No feature passed');\n    if (!name) throw new Error('.featureOf() requires a name');\n    if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n        throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n    }\n}\n\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nfunction collectionOf(featureCollection, type, name) {\n    if (!featureCollection) throw new Error('No featureCollection passed');\n    if (!name) throw new Error('.collectionOf() requires a name');\n    if (!featureCollection || featureCollection.type !== 'FeatureCollection') {\n        throw new Error('Invalid input to ' + name + ', FeatureCollection required');\n    }\n    for (var i = 0; i < featureCollection.features.length; i++) {\n        var feature = featureCollection.features[i];\n        if (!feature || feature.type !== 'Feature' || !feature.geometry) {\n            throw new Error('Invalid input to ' + name + ', Feature with geometry required');\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);\n        }\n    }\n}\n\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nfunction getGeom(geojson) {\n    if (!geojson) throw new Error('geojson is required');\n    if (geojson.geometry !== undefined) return geojson.geometry;\n    if (geojson.coordinates || geojson.geometries) return geojson;\n    throw new Error('geojson must be a valid Feature or Geometry Object');\n}\n\n/**\n * Get Geometry Type from Feature or Geometry Object\n *\n * @throws {Error} **DEPRECATED** in v5.0.0 in favor of getType\n */\nfunction getGeomType() {\n    throw new Error('invariant.getGeomType has been deprecated in v5.0 in favor of invariant.getType');\n}\n\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nfunction getType(geojson, name) {\n    if (!geojson) throw new Error((name || 'geojson') + ' is required');\n    // GeoJSON Feature & GeometryCollection\n    if (geojson.geometry && geojson.geometry.type) return geojson.geometry.type;\n    // GeoJSON Geometry & FeatureCollection\n    if (geojson.type) return geojson.type;\n    throw new Error((name || 'geojson') + ' is invalid');\n}\n\nexport { getCoord, getCoords, containsNumber, geojsonType, featureOf, collectionOf, getGeom, getGeomType, getType };\n","import destination from '@turf/destination';\nimport { polygon } from '@turf/helpers';\n\n/**\n * Takes a {@link Point} and calculates the circle polygon given a radius in degrees, radians, miles, or kilometers; and steps for precision.\n *\n * @name circle\n * @param {Feature<Point>|number[]} center center point\n * @param {number} radius radius of the circle\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.steps=64] number of steps\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] properties\n * @returns {Feature<Polygon>} circle polygon\n * @example\n * var center = [-75.343, 39.984];\n * var radius = 5;\n * var options = {steps: 10, units: 'kilometers', properties: {foo: 'bar'}};\n * var circle = turf.circle(center, radius, options);\n *\n * //addToMap\n * var addToMap = [turf.point(center), circle]\n */\nfunction circle(center, radius, options) {\n    // Optional params\n    options = options || {};\n    var steps = options.steps || 64;\n    var properties = options.properties;\n\n    // validation\n    if (!center) throw new Error('center is required');\n    if (!radius) throw new Error('radius is required');\n    if (typeof options !== 'object') throw new Error('options must be an object');\n    if (typeof steps !== 'number') throw new Error('steps must be a number');\n\n    // default params\n    steps = steps || 64;\n    properties = properties || center.properties || {};\n\n    var coordinates = [];\n    for (var i = 0; i < steps; i++) {\n        coordinates.push(destination(center, radius, i * -360 / steps, options).geometry.coordinates);\n    }\n    coordinates.push(coordinates[0]);\n\n    return polygon([coordinates], properties);\n}\n\nexport default circle;\n","import * as React from 'react';\nimport AppBar from '@material-ui/core/AppBar';\nimport ToolBar from '@material-ui/core/Toolbar';\nimport Typography from '@material-ui/core/Typography';\nimport { Theme } from '@material-ui/core/styles/createMuiTheme';\nimport withStyles, { WithStyles, StyleRules } from '@material-ui/core/styles/withStyles';\nimport createStyles from '@material-ui/core/styles/createStyles';\nimport { AutoSizer } from 'react-virtualized';\nimport circle from '@turf/circle';\nimport MapApp from '../components/MapApp';\n\nconst center = [140.46, 36.36];\nconst buffer = circle(center, 5000, {\n  units: 'meters'\n});\n\nconst styles = (theme: Theme): StyleRules =>\n  createStyles({\n    root: {},\n    autoSizerWrapper: {\n      height: 'calc(100vh - 56px)'\n    }\n  });\n\ninterface Props extends WithStyles<typeof styles> {}\n\nconst MapPage: React.FunctionComponent<Props> = (props: Props) => (\n  <div className={props.classes.root}>\n    <AppBar position=\"static\">\n      <ToolBar>\n        <Typography variant=\"h6\">Map Page</Typography>\n      </ToolBar>\n    </AppBar>\n    <div className={props.classes.autoSizerWrapper}>\n      <AutoSizer>{({ width, height }) => <MapApp width={width} height={height} feature={buffer} />}</AutoSizer>\n    </div>\n  </div>\n);\n\nexport default withStyles(styles)(MapPage);\n\n// helper\n","module.exports = \"data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0xMiAyQzguMTMgMiA1IDUuMTMgNSA5YzAgNS4yNSA3IDEzIDcgMTNzNy03Ljc1IDctMTNjMC0zLjg3LTMuMTMtNy03LTd6bTAiIGZpbGw9IiMwMDkxRUEiIHN0cm9rZT0id2hpdGUiIHN0cm9rZS13aWR0aD0iMSIvPgogICAgPHBhdGggZD0iTTEyIDExLjVjLTEuMzggMC0yLjUtMS4xMi0yLjUtMi41czEuMTItMi41IDIuNS0yLjUgMi41IDEuMTIgMi41IDIuNS0xLjEyIDIuNS0yLjUgMi41eiIgZmlsbD0id2hpdGUiLz4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz4KPC9zdmc+Cg==\"","import fetch from 'isomorphic-fetch';\n\nexport interface Tile {\n  id: string;\n  x: number;\n  y: number;\n  z: number;\n  tx: number;\n  ty: number;\n  scale: number;\n  translate: [number, number];\n  mag: number;\n}\n\ntype TileUrl = string | undefined;\n\nexport interface TileWithURL extends Tile {\n  url: TileUrl;\n}\n\nexport interface TileTree {\n  [key: string]: {\n    [key: string]: {\n      [key: string]: TileUrl;\n    };\n  };\n}\n\ninterface TileSetOptions {\n  url?: string;\n}\n\nclass TileSet {\n  readonly tileTree: TileTree;\n  readonly tileUrl: string;\n  constructor(options: TileSetOptions = {}) {\n    this.tileUrl = options.url || '//cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png';\n    this.tileTree = {};\n  }\n\n  private treeIncludesTile(tile: Tile): boolean {\n    const { x, y, z } = tile;\n    return (\n      this.tileTree.hasOwnProperty(z.toString()) &&\n      this.tileTree[z.toString()].hasOwnProperty(x.toString()) &&\n      this.tileTree[z.toString()][x.toString()].hasOwnProperty(y.toString())\n    );\n  }\n\n  private tile2tree(tile: TileWithURL) {\n    const { x, y, z, url } = tile;\n    if (!this.tileTree.hasOwnProperty(z.toString())) {\n      this.tileTree[z.toString()] = {\n        [x.toString()]: {\n          [y.toString()]: url\n        }\n      };\n    } else if (!this.tileTree[z.toString()].hasOwnProperty(x.toString())) {\n      this.tileTree[z.toString()][x.toString()] = {\n        [y.toString()]: url\n      };\n    } else {\n      this.tileTree[z.toString()][x.toString()][y.toString()] = url;\n    }\n  }\n  // fetch new tiles\n  private fetchTiles(tiles: Tile[]): Promise<TileWithURL[]> {\n    return new Promise(resolve => {\n      const tasks = tiles.map(tile => this.fetchTile(tile, this.tileUrl));\n      Promise.all(tasks).then((data: TileWithURL[]) => {\n        resolve(data);\n      });\n    });\n  }\n  private fetchTile(tile: Tile, url: string): Promise<TileWithURL> {\n    const { x, y, z } = tile;\n    const fetchUrl = url.replace('{z}/{x}/{y}', `${z}/${x}/${y}`);\n\n    return fetch(fetchUrl)\n      .then(res => {\n        if (!res.ok) throw new Error();\n        return res.blob();\n      })\n      .then(blob => {\n        const tileWithURL: TileWithURL = {\n          ...tile,\n          url: URL.createObjectURL(blob)\n        };\n        this.tile2tree(tileWithURL);\n        return tileWithURL;\n      })\n      .catch(() => {\n        const tileWithURL: TileWithURL = {\n          ...tile,\n          url: undefined\n        };\n        this.tile2tree(tileWithURL);\n        return tileWithURL;\n      });\n  }\n\n  // helpers\n\n  public isRequireFetch(tiles: Tile[]): boolean {\n    return !tiles.every(tile => this.treeIncludesTile(tile));\n  }\n\n  public setTileUrlFromTree(tiles: Tile[]): TileWithURL[] {\n    return tiles\n      .filter(tile => this.treeIncludesTile(tile))\n      .map(tile => ({\n        ...tile,\n        url: this.tileTree[tile.z][tile.x][tile.y]\n      }));\n  }\n\n  public async updateTiles(newTiles: Tile[]) {\n    const tilesInTree = this.setTileUrlFromTree(newTiles.filter(tile => this.treeIncludesTile(tile)));\n\n    const tilesShouldFetch = newTiles.filter(tile => !this.treeIncludesTile(tile));\n\n    const fetchedTiles: TileWithURL[] = await this.fetchTiles(tilesShouldFetch);\n\n    return [...tilesInTree, ...fetchedTiles];\n  }\n}\n\nexport default TileSet;\n","import * as React from 'react';\nimport { scaleLinear, scalePow, scaleSequential } from 'd3-scale';\nimport { interpolateSpectral } from 'd3-scale-chromatic';\nimport { Feature, Point } from '@turf/helpers';\nimport { GeoProjection } from 'd3-geo';\n\nimport { MeshProperties } from '../utils/types';\n\ninterface Props {\n  feature: Feature<Point, MeshProperties>;\n  projection: GeoProjection;\n}\n\nconst colorScale = scaleSequential(interpolateSpectral).domain([1000, 0]);\n\nconst sizeScale = scalePow()\n  .domain([0, 1000])\n  .range([0, 8])\n  .exponent(0.5);\n\nconst MeshRect: React.FunctionComponent<Props> = (props: Props) => {\n  const { feature, projection } = props;\n  const { val } = feature.properties;\n  const center = projection(feature.geometry.coordinates);\n  const size = Math.abs(sizeScale(val) * Math.max(1, projection.scale() / 125000));\n\n  return (\n    <rect\n      fill={colorScale(val)}\n      fillOpacity={0.6}\n      x={center[0] - size / 2}\n      y={center[1] - size / 2}\n      width={size}\n      height={size}\n      style={{ mixBlendMode: 'multiply' }}\n    />\n  );\n};\n\nexport default MeshRect;\n","import * as React from 'react';\n/*\nconst filterMatrix = [\n  \"0.3333 0.3333 0.3333 0 0\",\n  \"0.3333 0.3333 0.3333 0 0\",\n  \"0.3333 0.3333 0.3333 0 0\",\n  \"0 0 0 1 0\"\n];\n*/\nconst filterMatrix = ['0.3333 0.3333 0.3333 0 0', '0.3333 0.3333 0.3333 0 0', '0.3333 0.3333 0.3333 0 0', '0 0 0 1 0'];\n\ninterface Props {\n  id: string;\n}\n\nconst GrayScaleFilter: React.FunctionComponent<Props> = (props: Props) => (\n  <filter id={props.id}>\n    <feColorMatrix type=\"matrix\" values={filterMatrix.join(' ')} />\n  </filter>\n);\n\nexport default GrayScaleFilter;\n","import * as React from 'react';\nimport { Theme } from '@material-ui/core/styles/createMuiTheme';\nimport withStyles, { WithStyles, StyleRules } from '@material-ui/core/styles/withStyles';\nimport createStyles from '@material-ui/core/styles/createStyles';\nconst d3tile = require('d3-tile').tile;\n\nimport bbox from '@turf/bbox';\nimport { geoMercator, geoPath, GeoProjection, GeoPath } from 'd3-geo';\nimport TileSet, { Tile, TileWithURL } from '../utils/tileTree';\nimport MeshFeature from '../components/MeshFeature';\nimport GrayScaleFilter from '../components/GrayScaleFilter';\nimport { Feature, Point } from '@turf/helpers';\nimport { Buffer, MeshProperties, LocationWithState, MapState } from '../utils/types';\n\nimport Place from '../image/place.svg';\n\nconst styles = (theme: Theme): StyleRules =>\n  createStyles({\n    root: {},\n    tiles: {\n      //transition: 'opacity 1s'\n    },\n    buffer: {\n      opacity: 0.2,\n      '&:hover': {\n        opacity: 1\n      }\n    },\n    points: {\n      //transition: 'opacity 1s .5s'\n    }\n  });\n\ninterface D3TileArray<T> extends Array<T> {\n  scale: number;\n  translate: [number, number];\n}\n\ninterface Props extends WithStyles<typeof styles> {\n  width: number;\n  height: number;\n  mapState: MapState;\n  geojson: {\n    type: 'FeatureCollection';\n    features: Feature<Point, MeshProperties>[];\n  };\n  buffers: Buffer[];\n}\n\ninterface State {\n  readonly fetchStatus?: 'yet' | 'fetching' | 'fetched';\n}\n\nclass Map extends React.Component<Props, State> {\n  readonly state: State = {\n    fetchStatus: 'yet'\n  };\n  _tileSet = new TileSet();\n  // Tile Maps\n  // slope: //cyberjapandata.gsi.go.jp/xyz/slopemap/{z}/{x}/{y}.png\n\n  private _getTileCoordinates = (projection: GeoProjection): Tile[] => {\n    const { width, height } = this.props;\n    const mag: number = 1.5;\n\n    const tiles: Tile[] = d3tile()\n      .size([width * mag, height * mag])\n      .scale(projection.scale() * 2 * Math.PI * mag)\n      .translate(projection([0, 0]).map(v => v * mag))()\n      .map((tile: { x: number; y: number; z: number }, index: number, array: D3TileArray<Tile>) => ({\n        ...tile,\n        mag,\n        id: `${tile.z}/${tile.x}/${tile.y}`,\n        scale: array.scale,\n        translate: array.translate\n      }));\n\n    return tiles;\n  };\n\n  private _fetchTiles = (tiles: Tile[]) => {\n    return this._tileSet.updateTiles(tiles);\n  };\n\n  componentDidMount() {}\n\n  public render() {\n    const { classes, buffers, geojson, mapState } = this.props;\n    const { popVisibility, bufferVisibility, zoomLevel } = mapState;\n    const width = this.props.width || 400;\n    const height = this.props.height || 400;\n    const projection = buffers ? geoMercator().fitExtent([[10, 40], [width - 10, height - 40]], buffers[zoomLevel]) : geoMercator();\n\n    const path: GeoPath = geoPath(projection);\n    const tileCoords = this._getTileCoordinates(projection);\n\n    let renderTiles: TileWithURL[] = this._tileSet.setTileUrlFromTree(tileCoords);\n\n    if (this._tileSet.isRequireFetch(tileCoords)) {\n      this._fetchTiles(tileCoords).then(newTiles => {\n        this.setState({ fetchStatus: 'fetched' });\n      });\n    }\n\n    return (\n      <svg className={classes.root} width={width} height={height}>\n        <g>\n          <GrayScaleFilter id=\"grayscale\" />\n          <g filter=\"url(#grayscale)\" className={classes.tiles} style={{ opacity: this.state.fetchStatus === 'fetched' ? 1 : 0 }}>\n            {renderTiles.map((tile, index) => (\n              <image\n                key={index}\n                xlinkHref={tile.url}\n                x={((tile.x + tile.translate[0]) * tile.scale) / tile.mag}\n                y={((tile.y + tile.translate[1]) * tile.scale) / tile.mag}\n                width={tile.scale / tile.mag}\n                height={tile.scale / tile.mag}\n              />\n            ))}\n          </g>\n        </g>\n        {popVisibility ? (\n          <g className={classes.points} style={{ opacity: this.state.fetchStatus === 'fetched' ? 1 : 0 }}>\n            {geojson\n              ? geojson.features.map((feature, index) =>\n                  feature.geometry.type === 'Point' ? <MeshFeature key={index} feature={feature} projection={projection} /> : null\n                )\n              : null}\n          </g>\n        ) : null}\n        {bufferVisibility ? (\n          <g>\n            {buffers\n              ? buffers.map((feature, index) => {\n                  const bb = bbox(feature);\n                  const lb = projection([bb[2] + (bb[0] - bb[2]) / 2, bb[1]]);\n                  return (\n                    <g key={index} className={classes.buffer}>\n                      <path d={path(feature) || undefined} fill=\"none\" stroke=\"rgb(200, 60, 80)\" strokeWidth={3} />\n                      <text x={lb[0]} y={lb[1]} dy=\"1em\" textAnchor=\"middle\" fill=\"rgb(200, 60, 80)\" style={{ fontWeight: 'bold' }}>\n                        {feature.properties.radius}\n                      </text>\n                    </g>\n                  );\n                })\n              : null}\n          </g>\n        ) : null}\n        <g>\n          <image xlinkHref={Place} x={width / 2} y={height / 2} width={28} height={28} transform=\"translate(-14, -26)\" />\n        </g>\n      </svg>\n    );\n  }\n}\n\nexport default withStyles(styles)(Map);\n"],"sourceRoot":""}